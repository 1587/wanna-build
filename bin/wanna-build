#!/usr/bin/perl
# 
# wanna-build: coordination script for Debian buildds
# Copyright (C) 1998 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
# Copyright (C) 2005-2008 Ryan Murray <rmurray@debian.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

package conf;
# defaults
$basedir ||= "/var/lib/debbuild";
$dbbase ||= "build-db";
$transactlog ||= "transactions.log";
$mailprog ||= "/usr/sbin/sendmail";
require "/org/wanna-build/etc/wanna-build.conf";
die "$conf::basedir is not a directory\n" if ! -d $conf::basedir;
die "dbbase is empty\n" if ! $dbbase;
die "transactlog is empty\n" if ! $transactlog;
die "mailprog binary $conf::mailprog does not exist or isn't executable\n"
	if !-x $conf::mailprog;
die "no distributions defined\n" if ! %distributions;
package main;

use strict;
use POSIX;
use FileHandle;
use File::Copy;
use DBI;
use lib '/org/wanna-build/bin';
use WannaBuild;
use YAML::Tiny;
use Data::Dumper;
use Hash::Merge qw ( merge );
use String::Format;
use Date::Parse;
use List::Util qw[max];

our ($verbose, $mail_logs, $list_order, $list_state,
    $curr_date, $op_mode, $user, $real_user, $distribution,
    $fail_reason, $opt_override, $import_from, $export_to, $opt_create_db,
    %prioval, %sectval,
    $info_all_dists, $arch,
    $category, %catval, %short_category,
    $short_date, $list_min_age, $dbbase, @curr_time,
    $build_priority, %new_vers, $binNMUver, %merge_srcvers, %merge_binsrc,
    $printformat, $ownprintformat, $privmode
    );

# global vars
$ENV{'PATH'} = "/bin:/usr/bin:/usr/local/bin:/org/wanna-build/bin/";
$ENV{'LC_ALL'} = 'C';
$verbose = 0;
$mail_logs = "";
@curr_time = gmtime;
$curr_date = strftime("%Y %b %d %H:%M:%S",@curr_time);
$short_date = strftime("%m/%d/%y",@curr_time);
$| = 1;

# map program invocation names to operation modes
my %prognames = ( "uploaded-build"  => "set-uploaded",
				  "failed-build"    => "set-failed",
				  "no-build"		=> "set-not-for-us",
				  "give-back-build" => "set-needs-build",
				  "dep-wait-build"  => "set-dep-wait",
				  "forget-build"	=> "forget",
				  "merge-quinn"		=> "merge-quinn",
				  "merge-packages"  => "merge-packages",
				  "merge-sources"   => "merge-sources",
				  "build-info"		=> "info" );

%short_category = ( u => "uploaded-fixed-pkg",
				    f => "fix-expected",
					r => "reminder-sent",
					n => "nmu-offered",
					e => "easy",
					m => "medium",
					h => "hard",
					c => "compiler-error",
					"" => "none" );

my $progname;
($progname = $0) =~ s,.*/,,;
if ($prognames{$progname}) {
	$op_mode = $prognames{$progname};
}
elsif ($progname =~ /^list-(.*)$/) {
	$op_mode = "list";
	$list_state = ($1 eq "all") ? "" : $1;
}

my %options =
	(# flags
	 verbose        => { short => "v", flag => \$verbose },
	 override		=> { short => "o", flag => \$opt_override },
	 "create-db"	=> { flag => \$opt_create_db },
	 "correct-compare" => { flag => \$WannaBuild::opt_correct_version_cmp },
	 # TODO: remove after buildds no longer pass to wanna-build
	 "no-propagation" => { short => "N" },
	 "no-down-propagation" => { short => "D" },
	 # normal actions
	 take			=> { mode => "set-building" },
	 failed			=> { short => "f", mode => "set-failed" },
	 uploaded		=> { short => "u", mode => "set-uploaded" },
	 "no-build"		=> { short => "n", mode => "set-not-for-us" },
	 built			=> { mode => "set-built" },
	 attempted		=> { mode => "set-attempted" },
	 "give-back"	        => { mode => "set-needs-build" },
	 "dep-wait"		=> { mode => "set-dep-wait" },
	 forget			=> { mode => "forget" },
	 'forget-user' => { mode => 'forget-user' },
	 "merge-quinn"  => { mode => "merge-quinn" },
	 "merge-partial-quinn" => { mode => "merge-partial-quinn" },
	 "merge-packages" => { mode => "merge-packages" },
	 "merge-sources" => { mode => "merge-sources" },
	 "pretend-avail" => { short => "p", mode => "pretend-avail" },
	 "merge-all"     => { mode => "merge-all" },
	 "merge-all-secondary" => { mode => "merge-all-secondary" },
	 info			=> { short => "i", mode => "info" },
	 'binNMU' => { mode => 'set-binary-nmu', arg => \$binNMUver, 
			     code => sub { die "Invalid binNMU version: $binNMUver\n"
				if $binNMUver !~ /^([\d]*)$/ and $1 >= 0; } },
	 'perm-build-priority'    => { mode => "set-permanent-build-priority", arg => \$build_priority,
	 		      code => sub { die "Invalid build priority: $build_priority\n"
				if $build_priority !~ /^-?[\d]+$/; } },
	 'build-priority'    => { mode => "set-build-priority", arg => \$build_priority,
	 		      code => sub { die "Invalid build priority: $build_priority\n"
				if $build_priority !~ /^-?[\d]+$/; } },
	 list			=>
	 { short => "l", mode => "list", arg => \$list_state,
	   code => sub {
		   die "Unknown state to list: $list_state\n"
			   if !isin( $list_state, qw(needs-build building uploaded
						 built build-attempted failed installed dep-wait
						 not-for-us all failed-removed
						 install-wait reupload-wait bd-uninstallable));} },
	 # options with args
	 dist           =>
	 { short => "d", arg => \$distribution,
	   code => sub {
		   if ($distribution eq "a" || $distribution eq "all") {
			   $info_all_dists = 1;
			   $distribution = "";
		   }
		   else {
			   $distribution = "oldstable"   if $distribution eq "o";
			   $distribution = "stable"   if $distribution eq "s";
			   $distribution = "testing"  if $distribution eq "t";
			   $distribution = "unstable" if $distribution eq "u";
		   }
	   } },
	 order          =>
	 { short => "O", arg => \$list_order,
	   code => sub {
		   die "Bad ordering character\n"
			   if $list_order !~ /^[PSpsncbCW]+$/;
	   } },
	 message        => { short => "m", arg => \$fail_reason },
	 # database is deprecated, use arch instead.
	 database       => { short => "b", arg => \$conf::dbbase },
	 arch           => { short => "A", arg => \$arch },
	 user           => { short => "U", arg => \$user },
	 category		=> { short => "c", arg => \$category,
						 code => sub {
							 $category = $short_category{$category}
								 if exists $short_category{$category};
							 die "Unknown category: $category\n"
								 if !isin( $category, values %short_category );
						 } },
	 "min-age"      => { short => "a", arg => \$list_min_age,
						 code => sub {
							 die "Argument of --min-age must be a non-zero number\n"
								 if $list_min_age == 0;
						 } },
	 "max-age"      => { arg => \$list_min_age,
						 code => sub {
							 die "Argument of --max-age must be a non-zero number\n"
								 if $list_min_age == 0;
							 $list_min_age *= -1;
						 } },
         "format"       => { arg => \$printformat },
         "own-format"       => { arg => \$ownprintformat },
	 # special actions
	 export         => { arg => \$export_to, mode => "export" },
	 import         => { arg => \$import_from, mode => "import" },
	 "manual-edit"  => { mode => "manual-edit" },
	 );

while( @ARGV && $ARGV[0] =~ /^-/ ) {
	$_ = shift @ARGV;
	last if $_ eq "--";
	my($opt, $optname, $arg);
	if (/^--([^=]+)(=|$)/) {
		$optname = $1;
		$opt = $options{$optname};
		$arg = $1 if /^--\Q$optname\E=((.|\n)*)$/;
	}
	else {
		$optname = substr( $_, 1, 1 );
		$opt = (grep { defined($_->{short}) ? $_->{short} eq $optname : 0} values %options)[0];
		$arg = $1 if /^-$optname(.+)$/;
	}
	if (!$opt) {
		warn "Unknown option: --$1\n";
		usage();
	}
	if ($opt->{arg}) {
		if (!defined $arg) {
			die "$optname option missing argument\n" if !@ARGV;
			$arg = shift @ARGV;
		}
		${$opt->{arg}} = $arg;
	}
	elsif (defined $arg) {
		die "Option $optname takes no argument\n";
	}
	
	if ($opt->{mode}) {
		die "Conflicting operation modes\n" if $op_mode;
		$op_mode = $opt->{mode};
	}
	if ($opt->{flag}) {
		${$opt->{flag}}++;
	}
	if ($opt->{code}) {
		&{$opt->{code}};
	}
}

$op_mode = $category ? "set-failed" : "set-building"
	if !$op_mode; # default operation
$distribution ||= "unstable";
if ($distribution eq 'any-priv') {
    $privmode = 'yes';
    $distribution = 'any';
}
if ($distribution eq 'any-unpriv') {
    $privmode = 'no';
    $distribution = 'any';
}
undef $distribution if $distribution eq 'any';
if ($distribution) {
    my @dists = split(/[, ]+/, $distribution);
    foreach my $dist (@dists) {
        die "Bad distribution '$distribution'\n"
	    if !isin($dist, keys %conf::distributions);
    }
}
if (!isin ( $op_mode, qw(list) ) && ( !$distribution || $distribution =~ /[ ,]/)) {
    die "multiple distributions are only allowed for list";
}

# If they didn't specify an arch, try to get it from database name which
# is in the form of $arch/build-db
# This is for backwards compatibity with older versions that didn't
# specify the arch yet.
$conf::dbbase =~ m#^([^/]+)#;
$arch ||= $1;

# TODO: Check that it's an known arch (for that dist), and give
# a proper error.

if ($verbose) {
	my $version = '$Revision: db181a534e9d $ $Date: 2008/03/26 06:20:22 $ $Author: rmurray $';
	$version =~ s/(^\$| \$ .*$)//g;
	print "wanna-build $version for $distribution on $arch\n";
}

if (!@ARGV && !isin( $op_mode, qw(list merge-quinn merge-partial-quinn import export
				  merge-packages manual-edit
				  merge-sources))) {
	warn "No packages given.\n";
	usage();
}

$real_user = (getpwuid($<))[0];
die "Can't determine your user name\n"
	if $op_mode ne "list" && !$user &&
	   !($user = $real_user);

if (!$fail_reason) {
	if ($op_mode eq "set-failed" && !$category) {
		print "Enter reason for failing (end with '.' alone on ".
		      "its line):\n";
		my $line;
		while(!eof(STDIN)) {
			$line = <STDIN>;
			last if $line eq ".\n";
			$fail_reason .= $line;
		}
		chomp( $fail_reason );
	} elsif ($op_mode eq "set-dep-wait") {
		print "Enter dependencies (one line):\n";
		my $line;
		while( !$line && !eof(STDIN) ) {
			chomp( $line = <STDIN> );
		}
		die "No dependencies given\n" if !$line;
		$fail_reason = $line;
	} elsif ($op_mode eq "set-binary-nmu" and $binNMUver > 0) {
		print "Enter changelog entry (one line):\n";
		my $line;
		while( !$line && !eof(STDIN) ) {
			chomp( $line = <STDIN> );
		}
		die "No changelog entry given\n" if !$line;
		$fail_reason = $line;
	}
}

my $yamlmap = ();
my $yamldir = "/org/wanna-build/etc/yaml";
my @files = ('wanna-build.yaml');
if ((getpwuid($>))[7]) { push (@files, ((getpwuid($>))[7])."/.wanna-build.yaml"); }
if ($user =~ /(buildd.*)-/) { push (@files, "$1.yaml") };
if ($user) { push ( @files, "$user.yaml"); }
foreach my $file (@files) {
        my $cfile = File::Spec->rel2abs( $file, $yamldir );
	if ($verbose >= 2) { print "Trying to read $file ($cfile) ...\n"; }
	next unless -f $cfile;
	if ($verbose >= 2) { print "Read $file ($cfile) ...\n"; }
	my $m = YAML::Tiny->read( $cfile )->[0];
	$yamlmap = merge($m, $yamlmap);
}
if (not $yamlmap) {
	die "FATAL: no configuration found\n";
}
$list_order = $yamlmap->{"list-order"}{$list_state} if !$list_order and $list_state;
$list_order ||= $yamlmap->{"list-order"}{'default'};

my $dbh;

END {
	if (defined $dbh)
	{
		$dbh->disconnect or warn $dbh->errstr;
	}
}

my $schema_suffix = '';
if (isin( $op_mode, qw(list info)) && $distribution !~ /security/ && !(not -t and $user =~ /-/) && !($privmode eq 'yes')) {
	$dbh = DBI->connect("DBI:Pg:service=wanna-build") || 
		die "FATAL: Cannot open database: $DBI::errstr\n";
	$schema_suffix = '_public';
}
else
{
	$dbh = DBI->connect("DBI:Pg:service=wanna-build-privileged") || 
		die "FATAL: Cannot open database: $DBI::errstr\n";
}

# TODO: This shouldn't be needed, file a bug.
$dbh->{pg_server_prepare} = 0;

$dbh->begin_work or die $dbh->errstr;

process();

$dbh->commit;
$dbh->disconnect;

if ($mail_logs && $conf::log_mail) {
	send_mail( $conf::log_mail,
			   "wanna-build $distribution state changes $curr_date",
			   "State changes at $curr_date for distribution ".
			   "$distribution:\n\n$mail_logs\n" );
}

exit 0;


sub process {

	SWITCH: foreach ($op_mode) {
		/^set-(.+)/ && do {
			add_packages( $1, @ARGV );
			last SWITCH;
		};
		/^list/ && do {
			list_packages( $list_state );
			last SWITCH;
		};
		/^info/ && do {
			info_packages( @ARGV );
			last SWITCH;
		};
		/^forget-user/ && do {
			die "This operation is restricted to admin users\n"
				if (defined @conf::admin_users and
				    !isin( $real_user, @conf::admin_users));
			forget_users( @ARGV );
			last SWITCH;
		};
		/^forget/ && do {
			forget_packages( @ARGV );
			last SWITCH;
		};
		/^merge-partial-quinn/ && do {
			die "This operation is restricted to admin users\n"
				if (defined @conf::admin_users and
				    !isin( $real_user, @conf::admin_users));
			lock_table();
			parse_quinn_diff(1);
			last SWITCH;
		};
		/^merge-quinn/ && do {
			die "This operation is restricted to admin users\n"
				if (defined @conf::admin_users and
				    !isin( $real_user, @conf::admin_users));
			lock_table();
			parse_quinn_diff(0);
			last SWITCH;
		};
		/^merge-packages/ && do {
			die "This operation is restricted to admin users\n"
				if (defined @conf::admin_users and
				    !isin( $real_user, @conf::admin_users));
			lock_table();
			parse_packages(0);
			last SWITCH;
		};
		/^merge-sources/ && do {
			die "This operation is restricted to admin users\n"
				if (defined @conf::admin_users and
				    !isin( $real_user, @conf::admin_users));
			lock_table();
			parse_sources(0);
			last SWITCH;
		};
		/^pretend-avail/ && do {
			pretend_avail( @ARGV );
			last SWITCH;
		};
		/^merge-all$/ && do {
			die "This operation is restricted to admin users\n"
				if (defined @conf::admin_users and
				    !isin( $real_user, @conf::admin_users));
			lock_table();
			my @ARGS = @ARGV;
			@ARGV = ( $ARGS[0] );
			my $pkgs = parse_packages(0);
			@ARGV = ( $ARGS[1] );
			parse_quinn_diff(0);
			@ARGV = ( $ARGS[2] );
			my $srcs = parse_sources(1);
			call_edos_depcheck( $ARGS[0], $srcs );
			last SWITCH;
		};
		/^merge-all-secondary/ && do {
			die "This operation is restricted to admin users\n"
				if (defined @conf::admin_users and
				    !isin( $real_user, @conf::admin_users));
			# This is in case the chroot has multiple unrelated
			# dist, for instance unstable and experimental.
			# This is not for stable and proposed-updates.
			# The second packages file contains a combination
			# of all Packages files known to the buildd, the
			# first only for the current dist.
			lock_table();
			my @ARGS = @ARGV;
			@ARGV = ( $ARGS[0] );
			my $pkgs = parse_packages(0);
			@ARGV = ( $ARGS[3] );
			my $pkgs = parse_packages(1);
			@ARGV = ( $ARGS[1] );
			parse_quinn_diff(0);
			@ARGV = ( $ARGS[2] );
			my $srcs = parse_sources(1);
			call_edos_depcheck( $ARGS[3], $srcs );
			last SWITCH;
		};
		/^import/ && do {
			die "This operation is restricted to admin users\n"
				if (defined @conf::admin_users and
				    !isin( $real_user, @conf::admin_users));
			$dbh->do("DELETE from " . table_name() . 
				" WHERE distribution = ?", undef,
				$distribution)
				or die $dbh->errstr;
			forget_users();
			read_db( $import_from );
			last SWITCH;
		};
		/^export/ && do {
			export_db( $export_to );
			last SWITCH;
		};

		die "Unexpected operation mode $op_mode\n";
	}
	if (not -t and $user =~ /-/) {
		my $userinfo = get_user_info($user);
		if (!defined $userinfo)
		{
			add_user_info($user);
		}
		else
		{
			update_user_info($user);
		}
	}
}

sub add_packages {
	my $newstate = shift;
	my( $package, $name, $version, $ok, $reason );
	
	foreach $package (@_) {
		$package =~ s,^.*/,,; # strip path
		$package =~ s/\.(dsc|diff\.gz|tar\.gz|deb)$//; # strip extension
		$package =~ s/_[a-zA-Z\d-]+\.changes$//; # strip extension
		if ($package =~ /^([\w\d.+-]+)_([\w\d:.+~-]+)/) {
			($name,$version) = ($1,$2);
		}
		else {
			warn "$package: can't extract package name and version ".
				 "(bad format)\n";
			next;
		}

		if ($op_mode eq "set-building") {
			add_one_building( $name, $version );
		}
		elsif ($op_mode eq "set-built") {
			add_one_built( $name, $version );
		}
		elsif ($op_mode eq "set-attempted") {
			add_one_attempted( $name, $version );
		}
		elsif ($op_mode eq "set-uploaded") {
			add_one_uploaded( $name, $version );
		}
		elsif ($op_mode eq "set-failed") {
			add_one_failed( $name, $version );
		}
		elsif ($op_mode eq "set-not-for-us") {
			add_one_notforus( $name, $version );
		}
		elsif ($op_mode eq "set-needs-build") {
			add_one_needsbuild( $name, $version );
		}
		elsif ($op_mode eq "set-dep-wait") {
			add_one_depwait( $name, $version );
		}
		elsif ($op_mode eq "set-build-priority") {
			set_one_buildpri( $name, $version, 'buildpri' );
		}
		elsif ($op_mode eq "set-permanent-build-priority") {
			set_one_buildpri( $name, $version, 'permbuildpri' );
		}
		elsif ($op_mode eq "set-binary-nmu") {
			set_one_binnmu( $name, $version );
		}
	}
}

sub add_one_building {
	my $name = shift;
	my $version = shift;
	my( $ok, $reason );

	$ok = 1;
	my $pkg = get_source_info($name);
	if (defined($pkg)) {
		if ($pkg->{'state'} eq "Not-For-Us") {
			$ok = 0;
			$reason = "not suitable for this architecture";
		}
		elsif ($pkg->{'state'} =~ /^Dep-Wait/) {
			$ok = 0;
			$reason = "not all source dependencies available yet";
		}
		elsif ($pkg->{'state'} =~ /^BD-Uninstallable/) {
			$ok = 0;
			$reason = "source dependencies are not installable";
		}
		elsif ($pkg->{'state'} eq "Uploaded" &&
			   (version_lesseq($version, $pkg->{'version'}))) {
			$ok = 0;
			$reason = "already uploaded by $pkg->{'builder'}";
			$reason .= " (in newer version $pkg->{'version'})"
				if !version_eq($pkg, $version);
		}
		elsif ($pkg->{'state'} eq "Installed" &&
			   version_less($version,$pkg->{'version'})) {
			if ($opt_override) {
				print "$name: Warning: newer version $pkg->{'version'} ".
					  "already installed, but overridden.\n";
			}
			else {
				$ok = 0;
				$reason = "newer version $pkg->{'version'} already in ".
						  "archive; doesn't need rebuilding";
				print "$name: Note: If the following is due to an epoch ",
					  " change, use --override\n";
			}
		}
		elsif ($pkg->{'state'} eq "Installed" &&
			   pkg_version_eq($pkg,$version)) {
			$ok = 0;
			$reason = "is up-to-date in the archive; doesn't need rebuilding";
		}
		elsif ($pkg->{'state'} eq "Needs-Build" &&
			   version_less($version,$pkg->{'version'})) {
			if ($opt_override) {
				print "$name: Warning: newer version $pkg->{'version'} ".
					  "needs building, but overridden.";
			}
			else {
				$ok = 0;
				$reason = "newer version $pkg->{'version'} needs building, ".
						  "not $version";
			}
		}
		elsif (isin($pkg->{'state'},qw(Building Built Build-Attempted))) {
			if (version_less($pkg->{'version'},$version)) {
				print "$name: Warning: Older version $pkg->{'version'} ",
				      "is being built by $pkg->{'builder'}\n";
				if ($pkg->{'builder'} ne $user) {
					send_mail( $pkg->{'builder'},
							   "package takeover in newer version",
							   "You are building package '$name' in ".
							   "version $version\n".
							   "(as far as I'm informed).\n".
							   "$user now has taken the newer ".
							   "version $version for building.".
							   "You can abort the build if you like.\n" );
				}
			}
			else {
				if ($opt_override) {
					print "User $pkg->{'builder'} had already ",
					      "taken the following package,\n",
						  "but overriding this as you request:\n";
					send_mail( $pkg->{'builder'}, "package takeover",
							   "The package '$name' (version $version) that ".
							   "was taken by you\n".
							   "has been taken over by $user\n" );
				}
				elsif ($pkg->{'builder'} eq $user) {
					print "$name: Note: already taken by you.\n";
					print "$name: ok\n" if $verbose;
					return;
				}
				else {
					$ok = 0;
					$reason = "already taken by $pkg->{'builder'}";
					$reason .= " (in newer version $pkg->{'version'})"
						if !version_eq($pkg->{'version'}, $version);
				}
			}
		}
		elsif ($pkg->{'state'} =~ /^Failed/ &&
			   pkg_version_eq($pkg, $version)) {
			if ($opt_override) {
				print "The following package previously failed ",
					  "(by $pkg->{'builder'})\n",
					  "but overriding this as you request:\n";
				send_mail( $pkg->{'builder'}, "failed package takeover",
						   "The package '$name' (version $version) that ".
						   "is taken by you\n".
						   "and has failed previously has been taken over ".
						   "by $user\n" )
					if $pkg->{'builder'} ne $user;
			}
			else {
				$ok = 0;
				$reason = "build of $version failed previously:\n    ";
				$reason .= join( "\n    ", split( "\n", $pkg->{'failed'} ));
				$reason .= "\nalso the package doesn't need builing"
					if $pkg->{'state'} eq 'Failed-Removed';
			}
		}
	}
	if ($ok) {
		my $ok = 'ok';
		if ($pkg->{'binary_nmu_version'}) {
			print "$name: Warning: needs binary NMU $pkg->{'binary_nmu_version'}\n" .
			      "$pkg->{'binary_nmu_changelog'}\n";
			$ok = 'aok';
		} else {
			print "$name: Warning: Previous version failed!\n"
				if $pkg->{'previous_state'} =~ /^Failed/ ||
				   $pkg->{'state'} =~ /^Failed/;
		}
		change_state( \$pkg, 'Building' );
		$pkg->{'package'} = $name;
		$pkg->{'version'} = $version;
		$pkg->{'builder'} = $user;
		log_ta( $pkg, "--take" );
		update_source_info($pkg);
		print "$name: $ok\n" if $verbose;
	}
	else {
		print "$name: NOT OK!\n  $reason\n";
	}
}

sub add_one_attempted {
	my $name = shift;
	my $version = shift;
	my $pkg = get_source_info($name);

	if (!defined($pkg)) {
		print "$name: not registered yet.\n";
		return;
	}

	if (($pkg->{'state'} ne "Building") && ($pkg->{'state'} ne "Build-Attempted")) {
		print "$name: not taken for building (state is $pkg->{'state'}). ",
			  "Skipping.\n";
		return;
	}
	if ($pkg->{'builder'} ne $user) {
		print "$name: not taken by you, but by $pkg->{'builder'}. Skipping.\n";
		return;
	}
	elsif ( !pkg_version_eq($pkg, $version) ) {
		print "$name: version mismatch ".
			  "$(pkg->{'version'} ".
			  "by $pkg->{'builder'})\n";
		return;
	}

	change_state( \$pkg, 'Build-Attempted' );
	log_ta( $pkg, "--attempted" );
	update_source_info($pkg);
	print "$name: registered as uploaded\n" if $verbose;
}

sub add_one_built {
	my $name = shift;
	my $version = shift;
	my $pkg = get_source_info($name);

	if (!defined($pkg)) {
		print "$name: not registered yet.\n";
		return;
	}

        if (($pkg->{'state'} ne "Building") && ($pkg->{'state'} ne "Build-Attempted")) {
		print "$name: not taken for building (state is $pkg->{'state'}). ",
			  "Skipping.\n";
		return;
	}
	if ($pkg->{'builder'} ne $user) {
		print "$name: not taken by you, but by $pkg->{'builder'}. Skipping.\n";
		return;
	}
	elsif ( !pkg_version_eq($pkg, $version) ) {
		print "$name: version mismatch ".
			  "$(pkg->{'version'} ".
			  "by $pkg->{'builder'})\n";
		return;
	}
	change_state( \$pkg, 'Built' );
	log_ta( $pkg, "--built" );
	update_source_info($pkg);
	print "$name: registered as built\n" if $verbose;
}

sub add_one_uploaded {
	my $name = shift;
	my $version = shift;
	my $pkg = get_source_info($name);

	if (!defined($pkg)) {
		print "$name: not registered yet.\n";
		return;
	}

	if ($pkg->{'state'} eq "Uploaded" &&
		pkg_version_eq($pkg,$version)) {
		print "$name: already uploaded\n";
		return;
	}
	if (!isin( $pkg->{'state'}, qw(Building Built Build-Attempted))) {
		print "$name: not taken for building (state is $pkg->{'state'}). ",
			  "Skipping.\n";
		return;
	}
	if ($pkg->{'builder'} ne $user) {
		print "$name: not taken by you, but by $pkg->{'builder'}. Skipping.\n";
		return;
	}
	# strip epoch -- buildd-uploader used to go based on the filename.
	# (to remove at some point)
	my $pkgver;
	($pkgver = $pkg->{'version'}) =~ s/^\d+://;
	$version =~ s/^\d+://; # for command line use
	if ($pkg->{'binary_nmu_version'} ) {
		my $nmuver = binNMU_version($pkgver, $pkg->{'binary_nmu_version'});
		if (!version_eq( $nmuver, $version )) {
			print "$name: version mismatch ($nmuver registered). ",
				  "Skipping.\n";
			return;
		}
	} elsif (!version_eq($pkgver, $version)) {
		print "$name: version mismatch ($pkg->{'version'} registered). ",
			  "Skipping.\n";
		return;
	}

	change_state( \$pkg, 'Uploaded' );
	log_ta( $pkg, "--uploaded" );
	update_source_info($pkg);
	print "$name: registered as uploaded\n" if $verbose;
}

sub add_one_failed {
	my $name = shift;
	my $version = shift;
	my ($state, $cat);
	my $pkg = get_source_info($name);

	if (!defined($pkg)) {
		print "$name: not registered yet.\n";
		return;
	}
	$state = $pkg->{'state'};

	if ($state eq "Not-For-Us") {
		print "$name: not suitable for this architecture anyway. Skipping.\n";
		return;
	}
	elsif ($state eq "Failed-Removed") {
		print "$name: failed previously and doesn't need building. Skipping.\n";
		return;
	}
	elsif ($state eq "Installed") {
		print "$name: Is already installed in archive. Skipping.\n";
		return;
	}
	elsif ($pkg->{'builder'} &&
		   (($user ne $pkg->{'builder'}) &&
		    !($pkg->{'builder'} =~ /^(\w+)-\w+/ && $1 eq $user))) {
		print "$name: not taken by you, but by ".
			  "$pkg->{'builder'}. Skipping.\n";
		return;
	}
	elsif ( !pkg_version_eq($pkg, $version) ) {
		print "$name: version mismatch ".
			  "$(pkg->{'version'} ".
			  "by $pkg->{'builder'})\n";
		return;
	}

	$cat = $category;
	if (!$cat && $fail_reason =~ /^\[([^\]]+)\]/) {
		$cat = $1;
		$cat = $short_category{$cat} if exists $short_category{$cat};
		if (!isin( $cat, values %short_category )) {
			print "$name: Warning: unknown category $cat; discarded\n";
			$cat = "";
		}
		$fail_reason =~ s/^\[[^\]]+\][ \t]*\n*//;
	}

	if ($state eq "Needs-Build") {
		print "$name: Warning: not registered for building previously, ".
			  "but processing anyway.\n";
	}
	elsif ($state eq "Uploaded") {
		print "$name: Warning: marked as uploaded previously, ".
			  "but processing anyway.\n";
	}
	elsif ($state eq "Dep-Wait") {
		print "$name: Warning: marked as waiting for dependencies, ".
			  "but processing anyway.\n";
	}
	elsif ($state eq "BD-Uninstallable") {
		print "$name: Warning: marked as having uninstallable build-dependencies, ".
			  "but processing anyway.\n";
	}
	elsif ($state eq "Failed") {
		print "$name: already registered as failed; will append new message\n"
			if $fail_reason;
		print "$name: already registered as failed; changing category\n"
			if $cat;
	}

	if (($cat eq "reminder-sent" || $cat eq "nmu-offered") &&
		defined $pkg->{'failed_category'} &&
		$pkg->{'failed_category'} ne $cat) {
		(my $action = $cat) =~ s/-/ /;
		$fail_reason .= "\n$short_date: $action";
	}

	change_state( \$pkg, 'Failed' );
	$pkg->{'builder'} = $user;
	$pkg->{'failed'} .= "\n" if $pkg->{'failed'};
	$pkg->{'failed'} .= $fail_reason;
	$pkg->{'failed_category'} = $cat if $cat;
	if (defined $pkg->{'permbuildpri'}) {
		$pkg->{'buildpri'} = $pkg->{'permbuildpri'};
	} else {
		delete $pkg->{'buildpri'};
	}
	log_ta( $pkg, "--failed" );
	update_source_info($pkg);
	print "$name: registered as failed\n" if $verbose;
}

sub add_one_notforus {
	my $name = shift;
	my $version = shift;
	my $pkg = get_source_info($name);

	if ($pkg->{'state'} eq 'Not-For-Us') {
		# reset Not-For-Us state in case it's called twice; this is
		# the only way to get a package out of this state...
		# There is no really good state in which such packages should
		# be put :-( So use Failed for now.
		change_state( \$pkg, 'Failed' );
		$pkg->{'package'} = $name;
		$pkg->{'failed'} = "Was Not-For-Us previously";
		delete $pkg->{'builder'};
		delete $pkg->{'depends'};
		log_ta( $pkg, "--no-build(rev)" );
		print "$name: now not unsuitable anymore\n";

		send_mail( $conf::notforus_maint,
				   "$name moved out of Not-For-Us state",
				   "The package '$name' has been moved out of the Not-For-Us ".
				   "state by $user.\n".
				   "It should probably also be removed from ".
				   "Packages-arch-specific or\n".
				   "the action was wrong.\n" )
			if $conf::notforus_maint;
	}
	else {
		change_state( \$pkg, 'Not-For-Us' );
		$pkg->{'package'} = $name;
		delete $pkg->{'builder'};
		delete $pkg->{'depends'};
		delete $pkg->{'buildpri'};
		delete $pkg->{'binary_nmu_version'};
		delete $pkg->{'binary_nmu_changelog'};
		log_ta( $pkg, "--no-build" );
		print "$name: registered as unsuitable\n" if $verbose;

		send_mail( $conf::notforus_maint,
				   "$name set to Not-For-Us",
				   "The package '$name' has been set to state Not-For-Us ".
				   "by $user.\n".
				   "It should probably also be added to ".
				   "Packages-arch-specific or\n".
				   "the Not-For-Us state is wrong.\n" )
			if $conf::notforus_maint;
	}
	update_source_info($pkg);
}

sub add_one_needsbuild {
	my $name = shift;
	my $version = shift;
	my $state;
	my $pkg = get_source_info($name);

	if (!defined($pkg)) {
		print "$name: not registered; can't give back.\n";
		return;
	}
	$state = $pkg->{'state'};

	if ($state eq "BD-Uninstallable") {
		if ($opt_override) {
			print "$name: Forcing uninstallability mark to be removed. This is not permanent and might be reset with the next trigger run\n";

			change_state( \$pkg, 'Needs-Build' );
			delete $pkg->{'builder'};
			delete $pkg->{'depends'};
			log_ta( $pkg, "--give-back" );
			update_source_info($pkg);
			print "$name: given back\n" if $verbose;
			return;
		}
		else {
			print "$name: has uninstallable build-dependencies. Skipping\n",
				  "  (use --override to clear dependency list and ",
				  "give back anyway)\n";
			return;
		}
	}
	elsif ($state eq "Dep-Wait") {
		if ($opt_override) {
			print "$name: Forcing source dependency list to be cleared\n";
		}
		else {
			print "$name: waiting for source dependencies. Skipping\n",
				  "  (use --override to clear dependency list and ",
				  "give back anyway)\n";
			return;
		}
	}
	elsif (!isin( $state, qw(Building Built Build-Attempted))) {
		print "$name: not taken for building (state is $state).";
		if ($opt_override) {
			print "\n$name: Forcing give-back\n";
		}
		else {
			print " Skipping.\n";
			return;
		}
	}
	if (defined ($pkg->{'builder'}) && $user ne $pkg->{'builder'} &&
		!($pkg->{'builder'} =~ /^(\w+)-\w+/ && $1 eq $user) &&
		!$opt_override) {
		print "$name: not taken by you, but by ".
			  "$pkg->{'builder'}. Skipping.\n";
		return;
	}
	if (!pkg_version_eq($pkg, $version)) {
		print "$name: version mismatch ($pkg->{'version'} registered). ",
			  "Skipping.\n";
		return;
	}
	if ($distribution eq "unstable") {
		change_state( \$pkg, 'BD-Uninstallable' );
		$pkg->{'bd_problem'} = "Installability of build dependencies not tested yet";
	} else {
		change_state( \$pkg, 'Needs-Build' );
	}
	$pkg->{'builder'} = undef;
	$pkg->{'depends'} = undef;
	log_ta( $pkg, "--give-back" );
	update_source_info($pkg);
	print "$name: given back\n" if $verbose;
}

sub set_one_binnmu {
	my $name = shift;
	my $version = shift;
	my $pkg = get_source_info($name);
	my $state;

	if (!defined($pkg)) {
		print "$name: not registered; can't register for binNMU.\n";
		return;
	}
	my $db_ver = $pkg->{'version'};

	if (!version_eq($db_ver, $version)) {
		print "$name: version mismatch ($db_ver registered). ",
			  "Skipping.\n";
		return;
	}
	$state = $pkg->{'state'};

	if (defined $pkg->{'binary_nmu_version'}) {
		if ($binNMUver == 0) {
			change_state( \$pkg, 'Installed' );
			delete $pkg->{'builder'};
			delete $pkg->{'depends'};
			delete $pkg->{'binary_nmu_version'};
			delete $pkg->{'binary_nmu_changelog'};
		} elsif ($binNMUver <= $pkg->{'binary_nmu_version'}) {
			print "$name: already building binNMU $pkg->{'binary_nmu_version'}\n";
			return;
		} else {
			$pkg->{'binary_nmu_version'} = $binNMUver;
			$pkg->{'binary_nmu_changelog'} = $fail_reason;
			$pkg->{'notes'} = 'out-of-date';
			$pkg->{'buildpri'} = $pkg->{'permbuildpri'}
				if (defined $pkg->{'permbuildpri'});
		}
		log_ta( $pkg, "--binNMU" );
		update_source_info($pkg);
		return;
	} elsif ($binNMUver == 0) {
                print "${name}_$version: no scheduled binNMU to cancel.\n";
                return;
        }

	if ($state ne 'Installed') {
		print "${name}_$version: not installed; can't register for binNMU.\n";
		return;
	}

	my $fullver = binNMU_version($version,$binNMUver);
	if ( version_lesseq( $fullver, $pkg->{'installed_version'} ) )
	{
		print "$name: binNMU $fullver is not newer than current version $pkg->{'installed_version'}\n";
		return;
	}

	if ($distribution eq "unstable") {
		change_state( \$pkg, 'BD-Uninstallable' );
		$pkg->{'bd_problem'} = "Installability of build dependencies not tested yet";
	}
	else
	{
		change_state( \$pkg, 'Needs-Build' );
	}
	delete $pkg->{'builder'};
	delete $pkg->{'depends'};
	$pkg->{'binary_nmu_version'} = $binNMUver;
	$pkg->{'binary_nmu_changelog'} = $fail_reason;
	$pkg->{'notes'} = 'out-of-date';
	log_ta( $pkg, "--binNMU" );
	update_source_info($pkg);
	print "${name}: registered for binNMU $fullver\n" if $verbose;
}

sub set_one_buildpri {
	my $name = shift;
	my $version = shift;
	my $key = shift;
	my $pkg = get_source_info($name);
	my $state;

	if (!defined($pkg)) {
		print "$name: not registered; can't set priority.\n";
		return;
	}
	$state = $pkg->{'state'};

	if ($state eq "Not-For-Us") {
		print "$name: not suitable for this architecture. Skipping.\n";
		return;
	} elsif ($state eq "Failed-Removed") {
		print "$name: failed previously and doesn't need building. Skipping.\n";
		return;
        }
	if (!pkg_version_eq($pkg, $version)) {
		print "$name: version mismatch ($pkg->{'version'} registered). ",
			  "Skipping.\n";
		return;
	}
	if ( $build_priority == 0 ) {
		delete $pkg->{'buildpri'}
			if $key eq 'permbuildpri' and defined $pkg->{'buildpri'}
			and $pkg->{'buildpri'} == $pkg->{$key};
		delete $pkg->{$key};
	} else {
		$pkg->{'buildpri'} = $build_priority
			if $key eq 'permbuildpri';
		$pkg->{$key} = $build_priority;
	}
	update_source_info($pkg);
	print "$name: set to build priority $build_priority\n" if $verbose;
}

sub add_one_depwait {
	my $name = shift;
	my $version = shift;
	my $state;
	my $pkg = get_source_info($name);

	if (!defined($pkg)) {
		print "$name: not registered yet.\n";
		return;
	}
	$state = $pkg->{'state'};

	if ($state eq "Dep-Wait") {
		print "$name: merging with previously registered dependencies\n";
	}
	
	if (isin( $state, qw(Needs-Build Failed BD-Uninstallable))) {
		print "$name: Warning: not registered for building previously, ".
			  "but processing anyway.\n";
	}
	elsif ($state eq "Not-For-Us") {
		print "$name: not suitable for this architecture anyway. Skipping.\n";
		return;
	}
	elsif ($state eq "Failed-Removed") {
		print "$name: failed previously and doesn't need building. Skipping.\n";
		return;
	}
	elsif ($state eq "Installed") {
		print "$name: Is already installed in archive. Skipping.\n";
		return;
	}
	elsif ($state eq "Uploaded") {
		print "$name: Is already uploaded. Skipping.\n";
		return;
	}
	elsif ($pkg->{'builder'} &&
		   $user ne $pkg->{'builder'}) {
		print "$name: not taken by you, but by ".
			  "$pkg->{'builder'}. Skipping.\n";
		return;
	}
	elsif ( !pkg_version_eq($pkg,$version)) {
		print "$name: version mismatch ".
			  "($pkg->{'version'} ".
			  "by $pkg->{'builder'})\n";
		return;
	}
	elsif ($fail_reason =~ /^\s*$/ ||
		   !parse_deplist( $fail_reason, 1 )) {
		print "$name: Bad dependency list\n";
		return;
	}
	change_state( \$pkg, 'Dep-Wait' );
	$pkg->{'builder'} = $user;
	if (defined $pkg->{'permbuildpri'}) {
		$pkg->{'buildpri'} = $pkg->{'permbuildpri'};
	} else {
		delete $pkg->{'buildpri'};
	}
	my $deplist = parse_deplist( $pkg->{'depends'} );
	my $new_deplist = parse_deplist( $fail_reason );
	# add new dependencies, maybe overwriting old entries
	foreach (keys %$new_deplist) {
		$deplist->{$_} = $new_deplist->{$_};
	}
	$pkg->{'depends'} = build_deplist($deplist);
	log_ta( $pkg, "--dep-wait" );
	update_source_info($pkg);
	print "$name: registered as waiting for dependencies\n" if $verbose;
}


sub parse_sources {
	my %pkgs;
	my %srcver;
	my $name;
	my $full = shift;

	my $db = get_all_source_info();

	local($/) = ""; # read in paragraph mode
	while( <> ) {
		my( $version, $arch, $section, $priority, $builddep, $buildconf, $binaries );
		s/\s*$//m;
		/^Package:\s*(\S+)$/mi and $name = $1;
		/^Version:\s*(\S+)$/mi and $version = $1;
		/^Architecture:\s*(\S+)$/mi and $arch = $1;
		/^Section:\s*(\S+)$/mi and $section = $1;
		/^Priority:\s*(\S+)$/mi and $priority = $1;
		/^Build-Depends:\s*(.*)$/mi and $builddep = $1;
		/^Build-Conflicts:\s*(.*)$/mi and $buildconf = $1;
                /^Binary:\s*(.*)$/mi and $binaries = $1;

		next if (defined $srcver{$name} and version_less( $version, $srcver{$name} ));
		$srcver{$name} = $version;

		$pkgs{$name}{'ver'} = $version;
		$pkgs{$name}{'bin'} = $binaries;
		$pkgs{$name}{'dep'} = $builddep;
		$pkgs{$name}{'conf'} = $buildconf;
		my $pkg = $db->{$name};

		if (defined $pkg) {
			my $change = 0;

			if ($arch eq "all" && !version_less( $version, $pkg->{'version'} )) {
				# package is now Arch: all, delete it from db
				change_state( \$pkg, 'deleted' );
				log_ta( $pkg, "--merge-sources" );
				print "$name ($pkg->{'version'}): deleted ".
					  "from database, because now Arch: all\n"
						  if $verbose;
				del_source_info($name);
				delete $db->{$name};
				next;
			}

			# The "Version" should always be the source version --
			# not a possible binNMU version number.
			$pkg->{'version'} = $version, $change++
				if ($pkg->{'state'} eq 'Installed' and
				!version_eq( $pkg->{'version'}, $version));
			# Always update priority and section, if available
			$pkg->{'priority'} = $priority, $change++
				if defined $priority and (not defined($pkg->{'priority'}) or $pkg->{'priority'} ne $priority);

			$pkg->{'section'} = $section, $change++
				if defined $section and (not defined($pkg->{'section'}) or $pkg->{'section'} ne $section);

			update_source_info($pkg) if $change;
		}
	}
        # Now that we only have the latest source version, build the list
        # of binary packages from the Sources point of view
        foreach $name (keys %pkgs) {
            foreach my $bin (split( /\s*,\s*/, $pkgs{$name}{'bin'} ) ) {
                $merge_binsrc{$bin} = $name;
            }
        }
	# remove installed packages that no longer have source available
	# or binaries installed
        foreach $name (keys %$db) {
		next if $name =~ /^_/;
		my $pkg = $db->{$name};
		if (not defined($pkgs{$name})) {
			change_state( \$pkg, 'deleted' );
			log_ta( $pkg, "--merge-sources" );
			print "$name ($pkg->{'version'}): ".
				  "deleted from database, because ".
				  "not in Sources anymore\n"
					  if $verbose;
			del_source_info($name);
			delete $db->{$name};
		} else {
			next if !isin( $pkg->{'state'}, qw(Installed) );
			if ($full && not defined $merge_srcvers{$name}) {
                            change_state( \$pkg, 'deleted' );
                            log_ta( $pkg, "--merge-sources" );
                            print "$name ($pkg->{'version'}): ".
                                      "deleted from database, because ".
                                      "binaries don't exist anymore\n"
                                              if $verbose;
			    del_source_info($name);
			    delete $db->{$name};
                        } elsif ($full && version_less( $merge_srcvers{$name}, $pkg->{'version'})) {
                            print "$name ($pkg->{'version'}): ".
                                      "package is Installed but binaries are from ".
                                      $merge_srcvers{$name}. "\n"
                                              if $verbose;
                        }
                }
	}
	return \%pkgs;
}

# This function looks through a Packages file and sets the state of
# packages to 'Installed'
sub parse_packages {
	my $depwait_only = shift;
	my $installed;

	my $pkgs = get_all_source_info();
	local($/) = ""; # read in paragraph mode
	while( <> ) {
		my( $name, $version, $depends, $source, $sourcev, $architecture, $provides, $binaryv, $binnmu );
		s/\s*$//m;
		/^Package:\s*(\S+)$/mi and $name = $1;
		/^Version:\s*(\S+)$/mi and $version = $1;
		/^Depends:\s*(.*)$/mi and $depends = $1;
		/^Source:\s*(\S+)(\s*\((\S+)\))?$/mi and ($source,$sourcev) = ($1, $3);
		/^Architecture:\s*(\S+)$/mi and $architecture = $1;
		/^Provides:\s*(.*)$/mi and $provides = $1;
		next if !$name || !$version;
		next if ($arch ne $architecture and $architecture ne "all");
		next if (defined ($installed->{$name}) and $installed->{$name}{'version'} ne "" and
			version_lesseq( $version, $installed->{$name}{'version'} ));
		$installed->{$name}{'version'} = $version;
		next if $depwait_only;
		$installed->{$name}{'depends'} = $depends;
		$installed->{$name}{'all'} = 1 if $architecture eq "all";
		undef $installed->{$name}{'Provider'};
		$installed->{$name}{'Source'} = $source ? $source : $name;
		if ($provides) {
                    foreach (split( /\s*,\s*/, $provides )) {
                        if (not defined ($installed->{$_})) {
                            $installed->{$_}{'version'} = "";
                            $installed->{$_}{'Provider'} = $name;
                        }
                    }
		}
		if ( $version =~ /\+b(\d+)$/ ) {
                    $binnmu = $1;
		}
		$version = $sourcev if $sourcev;
		$binaryv = $version;
		$binaryv =~ s/\+b\d+$//;
		$installed->{$name}{'Sourcev'} = $sourcev ? $sourcev : $binaryv;
		$binaryv .= "+b$binnmu" if defined($binnmu);

		next if $architecture ne $arch;
		$name = $source if $source;
		next if defined($merge_srcvers{$name}) and $merge_srcvers{$name} eq $version;
		$merge_srcvers{$name} = $version;

		my $pkg = $pkgs->{$name};

		if (defined $pkg) {
			if (isin( $pkg->{'state'}, qw(Not-For-Us)) ||
				(isin($pkg->{'state'}, qw(Installed)) &&
				 version_lesseq($binaryv, $pkg->{'installed_version'}))) {
				print "Skipping $name because State == $pkg->{'state'}\n"
					if $verbose >= 2;
				next;
			}
			if ($pkg->{'binary_nmu_version'} ) {
				my $nmuver = binNMU_version($pkg->{'version'}, $pkg->{'binary_nmu_version'});
				if (version_less( $binaryv, $nmuver )) {
					print "Skipping $name ($version) because have newer ".
						"version ($nmuver) in db.\n"
							if $verbose >= 2;
					next;
				}
			} elsif (version_less($version, $pkg->{'version'})) {
				print "Skipping $name ($version) because have newer ".
					"version ($pkg->{'version'}) in db.\n"
						if $verbose >= 2;
				next;
			}

			if (!pkg_version_eq($pkg, $version) &&
			   $pkg->{'state'} ne "Installed") {
				warn "Warning: $name: newer version than expected appeared ".
					 "in archive ($version vs. $pkg->{'version'})\n";
				delete $pkg->{'builder'};
			}

			if (!isin( $pkg->{'state'}, qw(Uploaded) )) {
				warn "Warning: Package $name was not in uploaded state ".
					 "before (but in '$pkg->{'state'}').\n";
				delete $pkg->{'builder'};
				delete $pkg->{'depends'};
			}
		} else {
			$pkg = {};
			$pkg->{'version'} = $version;
		}
		
		change_state( \$pkg, 'Installed' );
		$pkg->{'package'} = $name;
		$pkg->{'installed_version'} = $binaryv;
		if (defined $pkg->{'permbuildpri'}) {
			$pkg->{'buildpri'} = $pkg->{'permbuildpri'};
		} else {
			delete $pkg->{'buildpri'};
		}
		$pkg->{'version'} = $version
			if version_less( $pkg->{'version'}, $version);
		delete $pkg->{'binary_nmu_version'};
		delete $pkg->{'binary_nmu_changelog'};
		log_ta( $pkg, "--merge-packages" );
		update_source_info($pkg);
		print "$name ($version) is up-to-date now.\n" if $verbose;
	}

	check_dep_wait( "--merge-packages", $installed );
	return $installed;
}

sub pretend_avail {
	my ($package, $name, $version, $installed);
	
	foreach $package (@_) {
		$package =~ s,^.*/,,; # strip path
		$package =~ s/\.(dsc|diff\.gz|tar\.gz|deb)$//; # strip extension
		$package =~ s/_[\w\d]+\.changes$//; # strip extension
		if ($package =~ /^([\w\d.+-]+)_([\w\d:.+~-]+)/) {
			($name,$version) = ($1,$2);
		}
		else {
			warn "$package: can't extract package name and version ".
				 "(bad format)\n";
			next;
		}
		$installed->{$name}{'version'} = $version;
	}

	check_dep_wait( "--pretend-avail", $installed );
}

sub check_dep_wait {
	my $action = shift;
	my $installed = shift;
	
	# check all packages in state Dep-Wait if dependencies are all
	# available now
	my $name;
	my $db = get_all_source_info();
        foreach $name (keys %$db) {
		next if $name =~ /^_/;
		my $pkg = $db->{$name};
		next if $pkg->{'state'} ne "Dep-Wait";
		my $deps = $pkg->{'depends'};
		if (!$deps) {
			print "$name: was in state Dep-Wait, but with empty ",
				  "dependencies!\n";
			goto make_needs_build;
		}
		my $deplist = parse_deplist($deps);
		my $new_deplist;
		my $allok = 1;
		my @removed_deps;
		foreach (keys %$deplist) {
			if (!exists $installed->{$_} ||
				($deplist->{$_}->{'rel'} && $deplist->{$_}->{'version'} &&
				 !version_compare( $installed->{$_}{'version'},
								   $deplist->{$_}->{'rel'},
								   $deplist->{$_}->{'version'}))) {
				$allok = 0;
				$new_deplist->{$_} = $deplist->{$_};
			}
			else {
				push( @removed_deps, $_ );
			}
		}
		if ($allok) {
		  make_needs_build:
			change_state( \$pkg, 'Needs-Build' );
			log_ta( $pkg, $action );
			delete $pkg->{'builder'};
			delete $pkg->{'depends'};
			print "$name ($pkg->{'version'}) has all ",
				  "dependencies available now\n" if $verbose;
			$new_vers{$name}++;
			update_source_info($pkg);
		}
		elsif (@removed_deps) {
			$pkg->{'depends'} = build_deplist( $new_deplist );
			print "$name ($pkg->{'version'}): some dependencies ",
				  "(@removed_deps) available now, but not all yet\n"
				if $verbose;
			update_source_info($pkg);
		}
	}
}

# This function accepts quinn-diff output (either from a file named on
# the command line, or on stdin) and sets the packages named there to
# state 'Needs-Build'.
sub parse_quinn_diff {
	my $partial = shift;
	my %quinn_pkgs;
	my $dubious = "";
	
	my $pkgs = get_all_source_info();

	while( <> ) {
		my $change = 0;
		next if !m,^([-\w\d/]*)/			# section
			       ([-\w\d.+]+)_			# package name
				   ([\w\d:.~+-]+)\.dsc\s*	# version
				   \[([^:]*):				# priority
				   ([^]]+)\]\s*$,x;			# rest of notes
		my($section,$name,$version,$priority,$notes) = ($1, $2, $3, $4, $5);
		$quinn_pkgs{$name}++;
		$section ||= "unknown";
		$priority ||= "unknown";
		$priority = "unknown" if $priority eq "-";
		$priority = "standard" if ($name eq "debian-installer");

		my $pkg = $pkgs->{$name};

		# Always update section and priority.
		if (defined($pkg)) {

			$pkg->{'section'}  = $section, $change++ if not defined
				$pkg->{'section'} or $section ne "unknown";
			$pkg->{'priority'} = $priority, $change++ if not defined
				$pkg->{'priority'} or $priority ne "unknown";
		}

		if (defined($pkg) &&
			$pkg->{'state'} =~ /^Dep-Wait/ &&
			version_less( $pkg->{'version'}, $version )) {
			change_state( \$pkg, 'Dep-Wait' );
			$pkg->{'version'}  = $version;
			delete $pkg->{'binary_nmu_version'};
			delete $pkg->{'binary_nmu_changelog'};
			log_ta( $pkg, "--merge-quinn" );
			$change++;
			print "$name ($version) still waiting for dependencies.\n"
				if $verbose;
		}
		elsif (defined($pkg) &&
			   $pkg->{'state'} =~ /-Removed$/ &&
			   version_eq($pkg->{'version'}, $version)) {
			# reinstantiate a package that has been removed earlier
			# (probably due to a quinn-diff malfunction...)
			my $newstate = $pkg->{'state'};
			$newstate =~ s/-Removed$//;
			change_state( \$pkg, $newstate );
			$pkg->{'version'}  = $version;
			$pkg->{'notes'}    = $notes;
			log_ta( $pkg, "--merge-quinn" );
			$change++;
			print "$name ($version) reinstantiated to $newstate.\n"
				if $verbose;
		}
		elsif (defined($pkg) &&
			   $pkg->{'state'} eq "Not-For-Us" &&
			   version_less( $pkg->{'version'}, $version )) {
			# for Not-For-Us packages just update the version etc., but
			# keep the state
			change_state( \$pkg, "Not-For-Us" );
			$pkg->{'package'}  = $name;
			$pkg->{'version'}  = $version;
			$pkg->{'notes'}    = $notes;
			delete $pkg->{'builder'};
			log_ta( $pkg, "--merge-quinn" );
			$change++;
			print "$name ($version) still Not-For-Us.\n" if $verbose;
		}
		elsif (!defined($pkg) ||
			   $pkg->{'state'} ne "Not-For-Us" &&
			   (version_less( $pkg->{'version'}, $version ) ||
			   ($pkg->{'state'} eq "Installed" && version_less($pkg->{'installed_version'}, $version)))) {

			if (defined( $pkg->{'state'} ) && isin( $pkg->{'state'}, qw(Building Built Build-Attempted))) {
				send_mail( $pkg->{'builder'},
						   "new version of $name (dist=$distribution)",
						   "As far as I'm informed, you're currently ".
						   "building the package $name\n".
						   "in version $pkg->{'version'}.\n\n".
						   "Now there's a new source version $version. ".
						   "If you haven't finished\n".
						   "compiling $name yet, you can stop it to ".
						   "save some work.\n".
						   "Just to inform you...\n".
						   "(This is an automated message)\n" );
				print "$name: new version ($version) while building ".
					  "$pkg->{'version'} -- sending mail ".
					  "to builder ($pkg->{'builder'})\n"
				  if $verbose;
			}
			change_state( \$pkg, 'Needs-Build' );
			$pkg->{'package'}  = $name;
			$pkg->{'version'}  = $version;
			$pkg->{'section'}  = $section;
			$pkg->{'priority'} = $priority;
			$pkg->{'notes'}    = $notes;
			delete $pkg->{'builder'};
			delete $pkg->{'binary_nmu_version'};
			delete $pkg->{'binary_nmu_changelog'};
			log_ta( $pkg, "--merge-quinn" );
			$new_vers{$name}++;
			$change++;
			print "$name ($version) needs rebuilding now.\n" if $verbose;
		}
		elsif (defined($pkg) &&
			   !version_eq( $pkg->{'version'}, $version ) &&
			   isin( $pkg->{'state'}, qw(Installed Not-For-Us) )) {
			print "$name: skipping because version in db ".
				  "($pkg->{'version'}) is >> than ".
				  "what quinn-diff says ($version) ".
				  "(state is $pkg->{'state'})\n"
					  if $verbose;
			$dubious .= "$pkg->{'state'}: ".
						"db ${name}_$pkg->{'version'} >> ".
						"quinn $version\n" if !$partial;
		}
		elsif ($verbose >= 2) {
			if ($pkg->{'state'} eq "Not-For-Us") {
				print "Skipping $name because State == ".
					  "$pkg->{'state'}\n";
			}
			elsif (!version_less($pkg->{'version'}, $version)) {
				print "Skipping $name because version in db ".
					  "($pkg->{'version'}) is >= than ".
					  "what quinn-diff says ($version)\n";
			}
		}
		update_source_info($pkg) if $change;
	}

	if ($dubious) {
		send_mail( $conf::db_maint,
				   "Dubious versions in " . table_name() . " "
				   . $distribution . " table",
				   "The following packages have a newer version in the ".
				   "wanna-build database\n".
				   "than what quinn-diff says, and this is strange for ".
				   "their state\n".
				   "It could be caused by a lame mirror, or the version ".
				   "in the database\n".
				   "is wrong.\n\n".
				   $dubious );
	}

	# Now re-check the DB for packages in states Needs-Build, Failed,
	# Dep-Wait or BD-Uninstallable and remove them if they're not listed
	# anymore by quinn-diff.
	if ( !$partial ) {
		my $name;
		my $db = get_all_source_info();
		foreach $name (keys %$db) {
			next if $name =~ /^_/;
			my $pkg = $db->{$name};
			next if defined $pkg->{'binary_nmu_version'};
			next if !isin( $pkg->{'state'},
						   qw(Needs-Build Building Built Build-Attempted Uploaded Failed Dep-Wait BD-Uninstallable) );
			my $virtual_delete = $pkg->{'state'} eq 'Failed';
								 
			if (!$quinn_pkgs{$name}) {
				change_state( \$pkg, $virtual_delete ?
							  $pkg->{'state'}."-Removed" :
							  'deleted' );
				log_ta( $pkg, "--merge-quinn" );
				print "$name ($pkg->{'version'}): ".
					  ($virtual_delete ? "(virtually) " : "") . "deleted ".
					  "from database, because not in quinn-diff anymore\n"
						  if $verbose;
				if ($virtual_delete) {
				    update_source_info($pkg);
				} else {
				    del_source_info($name);
				}
			}
		}
	}
}


# for sorting priorities and sections
BEGIN {
	%prioval = ( required             => -5,
				 important            => -4,
				 standard             => -3,
				 optional             => -2,
				 extra                => -1,
				 unknown              => -1 );
	%sectval = ( 
				 libs			=> -200,
				 'debian-installer'	=> -199,
				 base			=> -198,
				 devel			=> -197,
				 kernel			=> -196,
				 shells			=> -195,
				 perl			=> -194,
				 python			=> -193,
				 graphics		=> -192,
				 admin			=> -191,
				 utils			=> -190,
				 x11			=> -189,
				 editors		=> -188,
				 net			=> -187,
				 httpd			=> -186,
				 mail			=> -185,
				 news			=> -184,
				 tex			=> -183,
				 text			=> -182,
				 web			=> -181,
				 vcs			=> -180,
				 doc			=> -179,
				 localizations		=> -178,
				 interpreters		=> -177,
				 ruby			=> -176,
				 java			=> -175,
				 ocaml			=> -174,
				 lisp			=> -173,
				 haskell		=> -172,
				 'cli-mono'             => -171,
				 gnome			=> -170,
				 kde			=> -169,
				 xfce			=> -168,
				 gnustep		=> -167,
				 database		=> -166,
				 video			=> -165,
				 debug			=> -164,
				 games			=> -163,
				 misc			=> -162,
				 fonts			=> -161,
				 otherosfs		=> -160,
				 oldlibs		=> -159,
				 libdevel		=> -158,
				 sound			=> -157,
				 math			=> -156,
				 'gnu-r'		=> -155,
				 science		=> -154,
				 comm			=> -153,
				 electronics		=> -152,
				 hamradio		=> -151,
				 embedded		=> -150,
				 php			=> -149,
				 zope			=> -148,
	);
	foreach my $i (keys %sectval) {
		$sectval{"contrib/$i"} = $sectval{$i}+40;
		$sectval{"non-free/$i"} = $sectval{$i}+80;
	}
	$sectval{'unknown'}	= -165;

	%catval =  ( "none"			      => -20,
				 "uploaded-fixed-pkg" => -19,
				 "fix-expected"       => -18,
				 "reminder-sent"      => -17,
				 "nmu-offered"        => -16,
				 "easy"               => -15,
				 "medium"		      => -14,
				 "hard"		          => -13,
				 "compiler-error"     => -12 );
}

sub sort_list_func {
    my $map_funcs = {
        'C' => ['<=>', sub { return (-1) * $_[0]->{'calprio'}; }],
        'W' => ['<=>', sub { return (-1) * $_[0]->{'state_days'}; }],
        'P' => ['<=>', sub { return (-1) * $_[0]->{'buildpri'}; }],
        'p' => ['<=>', sub { return $prioval{$_[0]->{'priority'}}; }],
        's' => ['<=>', sub { return $sectval{$_[0]->{'section'}}; }],
        'n' => ['cmp', sub { return $_[0]->{'package'}; }],
        'b' => ['cmp', sub { return $_[0]->{'builder'}; }],
        'c' => ['<=>', sub { return ($_[0]->{'notes'} =~ /^(out-of-date|partial)/) ? 0: ($_[0]->{'notes'} =~ /^uncompiled/) ? 2 : 1; }],
        'f' => ['<=>', sub { return $catval{ $_[0]->{'failed_category'} ? $_[0]->{'failed_category'}: "none" }; }],
        'S' => ['<=>', sub { return $prioval{$_[0]->{'priority'}} > $prioval{'standard'}; }],
    };

	foreach my $letter (split( //, $list_order )) {
            my $r;
            $r = &{$map_funcs->{$letter}[1]}($a) <=> &{$map_funcs->{$letter}[1]}($b) if $map_funcs->{$letter}[0] eq '<=>';
            $r = &{$map_funcs->{$letter}[1]}($a) cmp &{$map_funcs->{$letter}[1]}($b) if $map_funcs->{$letter}[0] eq 'cmp';
            return $r if $r != 0;
	}
	return 0;
}

sub calculate_prio {
	my $priomap = $yamlmap->{priority};
	my $pkg = shift;
        my @s=split("/", $pkg->{'section'});
        $pkg->{'component'} = $s[0] if $s[1];
        $pkg->{'component'} ||= 'main';
	$pkg->{'calprio'} = 0;
	foreach my $k (keys %{$priomap->{keys}}) {
		$pkg->{'calprio'} += $priomap->{keys}->{$k}{$pkg->{$k}} if $pkg->{$k} and $priomap->{keys}->{$k}{$pkg->{$k}};
	}

	my $days = $pkg->{'state_days'};
	$days = $priomap->{'waitingdays'}->{'min'} if $priomap->{'waitingdays'}->{'min'} and $days < $priomap->{'waitingdays'}->{'min'};
	$days = $priomap->{'waitingdays'}->{'max'} if $priomap->{'waitingdays'}->{'max'} and $days > $priomap->{'waitingdays'}->{'max'};
	my $scale = $priomap->{'waitingdays'}->{'scale'} || 1;
	$pkg->{'calprio'} += $days * $scale;

	$pkg->{'calprio'} += $pkg->{'permbuildpri'} if  $pkg->{'permbuildpri'};
	$pkg->{'calprio'} += $pkg->{'buildpri'} if  $pkg->{'buildpri'};

	return $pkg;
}


sub seconds2time {
    my $t = shift;
    return "" unless $t;
    my $sec = $t % 60;
    my $min = int($t/60) % 60;
    my $hours = int($t / 3600);
    return sprintf("%d:%02d:%02d", $hours, $min, $sec) if $hours;
    return sprintf("%d:%02d", $min, $sec);
}


sub use_fmt {
    my $r;

    if (ref($_[0]) eq 'CODE') {
        $r = &{$_[0]};
    } else {
        $r = $_[0];
    }

    shift;
    my $t = shift;

    $r ||= "";
    return $r unless $t;

    my $pkg = shift;
    my $var = shift;
    if (substr($t,0,1) eq '!') {
        $t = substr($t,1);
        return "" if $r;
    } else {
        return "" unless $r;
    }
    if ($t =~ /%/) {
        return print_format($t, $pkg, $var);
    }
    return $t;
}
sub make_fmt { my $c = shift; my $pkg = shift; my $var = shift; return sub { use_fmt($c, $_[0], $pkg, $var); } };

sub print_format {
    my $printfmt = shift;
    my $pkg = shift;
    my $var = shift;
=pod
Within an format string, the following values are allowed (need to be preceded by %).
This can be combined to e.g.
wanna-build --format='wanna-build -A %a --give-back %p_%v' -A mipsel --list=failed

a Architecture
c section (e.g. libs or utils)
D in case of BD-Uninstallable the reason for the uninstallability
d distribution
E in case of Dep-Wait the packages being waited on, in case of Needs-Build the number in the queue
F in case of Failed the fail reason
n newline
o time of last successful build (seconds)
O time of last successful build (formated)
P previous state
p Package name
q time of last build (seconds)
Q time of last build (formated)
r max time of last (successful) build (seconds)
R max time of last (successful) build (formated)
S Package state
s Time in this state in full seconds since epoch
t time of state change
u Builder (e.g. buildd_mipsel-rem)
v Package version
V full Package version (i.e. with +b.., = %v%{+b}B%B
X the string normally between [], e.g. optional:out-of-date:calprio{61}:days{25}

%{Text}?  print Text in case ? is not empty; ? is never printed
%{!Text}? print Text in case ? is empty; ? is never printed
Text could contain further %. To start with !, use %!

=cut
    return stringf($printfmt, (
        'p' => make_fmt( $pkg->{'package'}, $pkg, $var),
        'a' => make_fmt( $arch, $pkg, $var),
        's' => make_fmt( sub { return floor(str2time($pkg->{'state_change'})); }, $pkg, $var),
        'v' => make_fmt( $pkg->{'version'}, $pkg, $var),
        'V' => make_fmt( sub { $pkg->{'binary_nmu_version'} ? $pkg->{'version'}."+b".$pkg->{'binary_nmu_version'} : $pkg->{'version'} }, $pkg, $var),
        'S' => make_fmt( $pkg->{'state'}, $pkg, $var),
        'u' => make_fmt( $pkg->{'builder'}, $pkg, $var),
        'X' => make_fmt( sub {
            my $c = "$pkg->{'priority'}:$pkg->{'notes'}";
            $c .= ":PREV-FAILED" if $pkg->{'previous_state'} =~ /^Failed/;
            $c .= ":bp{" . $pkg->{'buildpri'} . "}" if defined $pkg->{'buildpri'};
            $c .= ":binNMU{" . $pkg->{'binary_nmu_version'} . "}" if defined $pkg->{'binary_nmu_version'};
            $c .= ":calprio{". $pkg->{'calprio'}."}";
            $c .= ":days{". $pkg->{'state_days'}."}";
            return $c;
            }, $pkg, $var),
        'c' => make_fmt( $pkg->{'section'}, $pkg, $var),
        'P' => make_fmt( $pkg->{'previous_state'} || "unknwon", $pkg, $var),
        'E' => make_fmt( sub { return $pkg->{'depends'} if $pkg->{'state'} eq "Dep-Wait";
            return $var->{scnt}{'Needs-Build'} + 1 if $pkg->{'state'} eq 'Needs-Build';
            return ""; }, $pkg, $var),
	'F' => make_fmt( sub { return "" unless $pkg->{'failed'};
	    my $failed = $pkg->{'failed'};
	    $failed =~ s/\\/\\\\/g;
            return $pkg->{'package'}."#".$arch."-failure\n ".
	    join("\\0a",split("\n",$failed))."\\0a\n"; }, $pkg, $var),
        'D' => make_fmt( sub { return "" unless $pkg->{'bd_problem'};
            return $pkg->{'package'}."#".$arch."-bd-problem\n".
            join("\\0a",split("\n",$pkg->{'bd_problem'}))."\\0a\n"; }, $pkg, $var),
        'B' => make_fmt( sub { return $pkg->{'binary_nmu_version'} if defined $pkg->{'binary_nmu_version'}; }, $pkg, $var),
        'd' => make_fmt( $pkg->{'distribution'}, $pkg, $var),
        't' => make_fmt( $pkg->{'state_change'}, $pkg, $var),
        'o' => make_fmt( $pkg->{'successtime'}, $pkg, $var),
        'O' => make_fmt( sub { return seconds2time ( $pkg->{'successtime'}); }, $pkg, $var),
        'q' => make_fmt( $pkg->{'anytime'}, $pkg, $var),
        'Q' => make_fmt( sub { return seconds2time ( $pkg->{'anytime'}); }, $pkg, $var),
        'r' => make_fmt( sub { return max($pkg->{'successtime'}, $pkg->{'anytime'}); }, $pkg, $var),
        'R' => make_fmt( sub { return seconds2time ( max($pkg->{'successtime'}, $pkg->{'anytime'})); }, $pkg, $var),
    ));
}

sub list_packages {
	my $state = shift;
	my( $name, $pkg, @list );
	my $cnt = 0;
	my %scnt;
	my $ctime = time;

 	my $db = get_all_source_info(state => $state, user => $user, category => $category, list_min_age => $list_min_age);
	foreach $name (keys %$db) {
		next if $name =~ /^_/;
		push @list, calculate_prio($db->{$name});
	}

        # filter components
        @list = grep { my $i = $_->{'component'}; grep { $i eq $_ } split /[, ]+/, $yamlmap->{"restrict"}{'component'} } @list;

        # first adjust ownprintformat, then set printformat accordingly
        $printformat ||= $yamlmap->{"format"}{$ownprintformat};
        $printformat ||= $yamlmap->{"format"}{"default"}{$state};
        $printformat ||= $yamlmap->{"format"}{"default"}{"default"};
        undef $printformat if ($ownprintformat eq 'none');

	foreach $pkg (sort sort_list_func @list) {
                if ($printformat) {
                    print print_format($printformat, $pkg, {'cnt' => $cnt, 'scnt' => \%scnt})."\n";
		    ++$cnt;
		    $scnt{$pkg->{'state'}}++;
                    next;
                }
		print print_format("%c/%p_%v", $pkg, {});
		print print_format(": %S", $pkg, {})
			if $state eq "all";
		print print_format("%{ by }u%u", $pkg, {})
			if $pkg->{'state'} ne "Needs-Build";
		print print_format(" [%X]\n", $pkg, {});
		print "  Reasons for failing:\n",
			  "    [Category: ",
			  defined $pkg->{'failed_category'} ? $pkg->{'failed_category'} : "none",
			  "]\n    ",
			  join("\n    ",split("\n",$pkg->{'failed'})), "\n"
			if $pkg->{'state'} =~ /^Failed/;
		print "  Dependencies: $pkg->{'depends'}\n"
			if $pkg->{'state'} eq "Dep-Wait";
		print "  Reasons for BD-Uninstallable:\n    ",
		          join("\n    ",split("\n",$pkg->{'bd_problem'})), "\n"
			if $pkg->{'state'} eq "BD-Uninstallable";
		print "  Previous state was $pkg->{'previous_state'}\n"
			if $verbose && $pkg->{'previous_state'};
		print "  No previous state recorded\n"
			if $verbose && !$pkg->{'previous_state'};
		print "  State changed at $pkg->{'state_change'}\n"
			if $verbose && $pkg->{'state_change'};
		print "  Previous state $pkg->{'previous_state'} left $pkg->{'state_time'} ago\n"
			if $verbose && $pkg->{'previous_state'};
		print "  Previous failing reasons:\n    ",
		      join("\n    ",split("\n",$pkg->{'old_failed'})), "\n"
			if $verbose && $pkg->{'old_failed'};
		++$cnt;
		$scnt{$pkg->{'state'}}++ if $state eq "all";
	}
	if ($state eq "all" && !$printformat) {
		foreach (sort keys %scnt) {
			print "Total $scnt{$_} package(s) in state $_.\n";
		}
	}
	print "Total $cnt package(s)\n" unless $printformat;
	
}

sub info_packages {
	my( $name, $pkg, $key, $dist );
	my @firstkeys = qw(package version builder state section priority
					   installed_version previous_state state_change);
	my @dists = $info_all_dists ? keys %conf::distributions : ($distribution);
	my %beautykeys = ( 'package' => 'Package', 'version' => 'Version', 'builder' => 'Builder',
		'state' => 'State', 'section' => 'Section', 'priority' => 'Priority',
		'installed_version' => 'Installed-Version', 'previous_state' => 'Previous-State',
		'state_change' => 'State-Change',
		'bd_problem' => 'BD-Problem', 
		'binary_nmu_changelog' => 'Binary-NMU-Changelog', 'binary_nmu_version' => 'Binary-NMU-Version',
		'buildpri' => 'BuildPri', 'depends' => 'Depends', 'failed' => 'Failed',
		'failed_category' => 'Failed-Category', 'notes' => 'Notes',
		'distribution' => 'Distribution', 'old_failed' => 'Old-Failed',
		'permbuildpri' => 'PermBuildPri', 'rel' => 'Rel',
		'calprio' => 'CalculatedPri', 'state_days' => 'State-Days',
                'successtime' => 'Success-build-time',
                'anytime' => 'Build-time'
			 );
	
	foreach $name (@_) {
		$name =~ s/_.*$//; # strip version
		foreach $dist (@dists) {
			my $pname = "$name" . ($info_all_dists ? "($dist)" : "");
			
			$pkg = get_readonly_source_info($name);
			if (!defined( $pkg )) {
				print "$pname: not registered\n";
				next;
			}
			$pkg = calculate_prio($pkg);

			print "$pname:\n";
			foreach $key (@firstkeys) {
				next if !defined $pkg->{$key};
				my $val = $pkg->{$key};
				chomp( $val );
				$val = "\n$val" if isin( $key, qw(Failed Old-Failed));
				$val =~ s/\n/\n    /g;
				my $print_key = $key;
				$print_key = $beautykeys{$print_key} if $beautykeys{$print_key};
				printf "  %-20s: %s\n", $print_key, $val;
			}
			foreach $key (sort keys %$pkg) {
				next if isin( $key, @firstkeys );
				my $val = $pkg->{$key};
				next if !defined($val);
				chomp( $val );
				$val = "\n$val" if isin( $key, qw(Failed Old-Failed));
				$val =~ s/\n/\n    /g;
				my $print_key = $key;
				$print_key = $beautykeys{$print_key} if $beautykeys{$print_key};
				printf "  %-20s: %s\n", $print_key, $val;
			}
		}
	}
}

sub forget_packages {
	my( $name, $pkg, $key, $data );
	
	foreach $name (@_) {
		$name =~ s/_.*$//; # strip version
		$pkg = get_source_info($name);
		if (!defined( $pkg )) {
			print "$name: not registered\n";
			next;
		}

		$data = "";
		foreach $key (sort keys %$pkg) {
			my $val = $pkg->{$key};
			chomp( $val );
			$val =~ s/\n/\n /g;
			$data .= sprintf "  %-20s: %s\n", $key, $val;
		}
		send_mail( $conf::db_maint,
				   "$name deleted from DB " . table_name() . " " . $distribution,
				   "The package '$name' has been deleted from the database ".
				   "by $user.\n\n".
				   "Data registered about the deleted package:\n".
				   "$data\n" ) if $conf::db_maint;
		change_state( \$pkg, 'deleted' );
		log_ta( $pkg, "--forget" );
		del_source_info($name);
		print "$name: deleted from database\n" if $verbose;
	}
}

sub forget_users {
	$dbh->do("DELETE from " . user_table_name() . 
		" WHERE distribution = ?", undef, $distribution) or die $dbh->errstr;
}

sub read_db {
	my $file = shift;

	print "Reading ASCII database from $file..." if $verbose >= 1;
	open( F, "<$file" ) or
		die "Can't open database $file: $!\n";

	local($/) = ""; # read in paragraph mode
	while( <F> ) {
		my( %thispkg, $name );
		s/[\s\n]+$//;
		s/\n[ \t]+/\376\377/g;  # fix continuation lines
		s/\376\377\s*\376\377/\376\377/og;
  
		while( /^(\S+):[ \t]*(.*)[ \t]*$/mg ) {
			my ($key, $val) = ($1, $2);
			$key =~ s/-/_/g;
			$key =~ tr/A-Z/a-z/;
			$val =~ s/\376\377/\n/g;
			$thispkg{$key} = $val;
		}
		check_entry( \%thispkg );
		# add to db
		if (exists($thispkg{'package'})) {
			update_source_info(\%thispkg);
		}
		elsif(exists($thispkg{'user'})) {
			# user in import, username in database.
			$dbh->do('INSERT INTO ' . user_table_name() .
					' (username, distribution, last_seen)' .
					' values (?, ?, ?)',
				undef, $thispkg{'user'}, $distribution,
				$thispkg{'last_seen'})
				or die $dbh->errstr;
		 }
	}
	close( F );
	print "done\n" if $verbose >= 1;
}

sub check_entry {
	my $pkg = shift;
	my $field;

	return if $op_mode eq "manual-edit"; # no checks then
	
	# check for required fields
	if (exists $pkg->{'user'}) {
		return;
	}
	if (!exists $pkg->{'package'}) {
		print STDERR "Bad entry: ",
			  join( "\n", map { "$_: $pkg->{$_}" } keys %$pkg ), "\n";
		die "Database entry lacks package or username field\n";
	}
	# if no State: field, generate one (for old db compat)
	if (!exists($pkg->{'state'})) {
		$pkg->{'state'} =
			exists $pkg->{'failed'} ? 'Failed' : 'Building';
	}
	if (!exists $pkg->{'version'} and $pkg->{'state'} ne 'Not-For-Us') {
		die "Database entry for $pkg->{'package'} lacks Version: field\n";
	}
	# check state field
	die "Bad state $pkg->{'state'} of package $pkg->{Package}\n"
		if !isin( $pkg->{'state'},
				  qw(Needs-Build Building Built Build-Attempted Uploaded Installed Dep-Wait Dep-Wait-Removed
					 Failed Failed-Removed Not-For-Us BD-Uninstallable
					 ) );
}

sub export_db {
	my $file = shift;
	my($name,$pkg,$key);

	print "Writing ASCII database to $file..." if $verbose >= 1;
	open( F, ">$file" ) or
		die "Can't open export $file: $!\n";

        my $db = get_all_source_info();
        foreach $name (keys %$db) {
		next if $name =~ /^_/;
		my $pkg = $db->{$name};
		foreach $key (keys %{$pkg}) {
			my $val = $pkg->{$key};
			next if !defined($val);
			$val =~ s/\n*$//;
			$val =~ s/^/ /mg;
			$val =~ s/^ +$/ ./mg;
			print F "$key: $val\n";
		}
		print F "\n";
       }
       close( F );
       print "done\n" if $verbose >= 1;
}

sub change_state {
	my $pkgr = shift;
	my $pkg = $$pkgr;
	my $newstate = shift;
	my $state = \$pkg->{'state'};
	
	return if defined($$state) and $$state eq $newstate;
        $pkg->{'previous_state'} = $$state if defined($$state);
	$pkg->{'state_change'} = $curr_date;
	$pkg->{'do_state_change'} = 1;

	if (defined($$state) and $$state eq 'Failed') {
		$pkg->{'old_failed'} =
			"-"x20 . " $pkg->{'version'} " . "-"x20 . "\n" .
			$pkg->{'failed'} . "\n" .
			$pkg->{'old_failed'};
		delete $pkg->{'failed'};
		delete $pkg->{'failed_category'};
	}
	if (defined($$state) and $$state eq 'BD-Uninstallable') {
		delete $pkg->{'bd_problem'};
	}
	$$state = $newstate;
}

sub log_ta {
	my $pkg = shift;
	my $action = shift;
        my $dist = $distribution;
	my $str;
	my $prevstate;

	$prevstate = $pkg->{'previous_state'};
	$str = "$action($dist): $pkg->{'package'}_$pkg->{'version'} ".
		   "changed from $prevstate to $pkg->{'state'} ".
		   "by $real_user as $user";
	
	$dbh->do('INSERT INTO ' . transactions_table_name() .
			' (package, distribution, version, action, ' .
			' prevstate, state, real_user, set_user, time) ' .
			' values (?, ?, ?, ?, ?, ?, ?, ?, ?)',
		undef, $pkg->{'package'}, $distribution,
		$pkg->{'version'}, $action, $prevstate, $pkg->{'state'},
		$real_user, $user, 'now()') or die $dbh->errstr;

	if (!($prevstate eq 'Failed' && $pkg->{'state'} eq 'Failed')) {
		$str .= " (with --override)"
			if $opt_override;
		$mail_logs .= "$str\n";
	}
}


sub send_mail {
	my $to = shift;
	my $subject = shift;
	my $text = shift;

	my $from = $conf::db_maint;
	my $domain = $conf::buildd_domain;

	$from .= "\@$domain" if $from !~ /\@/;

	$to .= '@' . $domain if $to !~ /\@/;
	$text =~ s/^\.$/../mg;
	local $SIG{'PIPE'} = 'IGNORE';
	open( PIPE,  "| $conf::mailprog -oem $to" )
		or die "Can't open pipe to $conf::mailprog: $!\n";
	chomp $text;
	print PIPE "From: $from\n";
	print PIPE "Subject: $subject\n\n";
	print PIPE "$text\n";
	close( PIPE );
}

# for parsing input to dep-wait
sub parse_deplist {
    my $deps = shift;
    my $verify = shift;
    my %result;
    
    foreach (split( /\s*,\s*/, $deps )) {
        if ($verify) {
            # verification requires > starting prompts, no | crap
            if (!/^(\S+)\s*(\(\s*(>(?:[>=])?)\s*(\S+)\s*\))?\s*$/) {
                return 0;
            }
            next;
        }
        my @alts = split( /\s*\|\s*/, $_ );
        # Anything with an | is ignored, as it can be configured on a
        # per-buildd basis what will be installed
        next if $#alts != 0;
        $_ = shift @alts;

        if (!/^(\S+)\s*(\(\s*(>=|=|==|>|>>|<<|<=)\s*(\S+)\s*\))?\s*$/) {
            warn( "parse_deplist: bad dependency $_\n" );
            next;
        }
        my($dep, $rel, $relv) = ($1, $3, $4);
        $rel = ">>" if defined($rel) and $rel eq ">";
        $result{$dep}->{'package'} = $dep;
        if ($rel && $relv) {
            $result{$dep}->{'rel'} = $rel;
            $result{$dep}->{'version'} = $relv;
        }
    }
    return 1 if $verify;
    return \%result;
}

sub build_deplist {
	my $list = shift;
	my($key, $result);
	
	foreach $key (keys %$list) {
		$result .= ", " if $result;
		$result .= $key;
		$result .= " ($list->{$key}->{'rel'} $list->{$key}->{'version'})"
			if $list->{$key}->{'rel'} && $list->{$key}->{'version'};
	}
	return $result;
}

sub call_edos_depcheck {
    my $packagesfile = shift;
    my $srcs = shift;
    my $key;
    
    return if defined ($conf::distributions{$distribution}{noadw});

    # We need to check all of needs-build, as any new upload could make
    # something in needs-build have uninstallable deps
    # We also check everything in bd-uninstallable, as any new upload could
    # make that work again
    my %interesting_packages;
    my $db = get_all_source_info();
    foreach $key (keys %$db) {
	my $pkg = $db->{$key};
        if (defined $pkg and isin($pkg->{'state'}, qw/Needs-Build BD-Uninstallable/)) {
		$interesting_packages{$key} = undef;
	}
    }
    
    #print "I would look at these sources with edos-depcheck:\n";
    #print join " ", keys %interesting_packages,"\n";

    my $tmpfile_pattern = "/tmp/wanna-build-interesting-sources-$distribution.$$-";
    my ($tmpfile, $i);
    for( $i = 0;; ++$i ) {
	    $tmpfile = $tmpfile_pattern . $i;
	    last if ! -e $tmpfile;
    }

    open SOURCES, '>', $tmpfile or die "Could not open temporary file $tmpfile\n";
    for my $key (keys %interesting_packages) {
	my $pkg = $db->{$key};
	print SOURCES "Package: $key\n";
	print SOURCES "Version: $pkg->{'version'}\n";
	print SOURCES "Build-Depends: $srcs->{$key}{'dep'}\n" if $srcs->{$key}{'dep'};
	print SOURCES "Build-Conflicts: $srcs->{$key}{'conf'}\n" if $srcs->{$key}{'conf'};
	print SOURCES "Architecture: all\n";
	print SOURCES "\n";
    }
    close SOURCES;

    if (open(EDOS,"-|","wb-edos-builddebcheck", "-a", $arch, $packagesfile, $tmpfile))
    {
	local($/) = ""; # read in paragraph mode
	while( <EDOS> ) {
		my( $key, $reason ) ;
		s/\s*$//m;
		/^Package:\s*(\S+)$/mi and $key = $1;
		/^Failed-Why:(([^\n]|\n ([^\n]|\.))*)$/msi and $reason = $1;
		$reason =~ s/^\s*//mg;
		$reason ||= 'No reason given by edos-debcheck';

		if (exists $interesting_packages{$key}) {
		    $interesting_packages{$key} = $reason;
		} else {
		    #print "TODO: edos reported a package we do not care about now\n" if $verbose;
		}
	}
	close EDOS;
    } else {
	print "ERROR: Could not run wb-edos-builddebcheck. I am continuing, assuming\n" .
	      "all packages have installable build-dependencies."
    }
    
    unlink( $tmpfile );

    for my $key (keys %interesting_packages) {
	my $pkg = $db->{$key};
	my $change = 
	    (defined $interesting_packages{$key} and $pkg->{'state'} eq 'Needs-Build') ||
	    (not defined $interesting_packages{$key} and $pkg->{'state'} eq 'BD-Uninstallable');
	my $problemchange = $interesting_packages{$key} ne $pkg->{'bd_problem'};
	if ($change) {
	    if (defined $interesting_packages{$key}) {
		    change_state( \$pkg, 'BD-Uninstallable' );
		    $pkg->{'bd_problem'} = $interesting_packages{$key};
	    } else {
		    change_state( \$pkg, 'Needs-Build' );
	    }
	}
	if ($problemchange) {
	    if (defined $interesting_packages{$key}) {
		    $pkg->{'bd_problem'} = $interesting_packages{$key};
	    }	
	}
	if ($change) {
	    log_ta( $pkg, "--merge-all" );
	    print "edos-builddebchange changed state of ${key}_$pkg->{'version'} to $pkg->{'state'}\n" if $verbose;
	}
	if ($change || $problemchange) {
	    update_source_info($pkg);
	}
    }
}

sub usage {
	my $prgname;
	($prgname = $0) =~ s,^.*/,,;
	print <<"EOF";
Usage: $prgname <options...> <package_version...>
Options:
    -v, --verbose: Verbose execution.
    -A arch: Architecture this operation is for.
    --take: Take package for building [default operation]
    -f, --failed: Record in database that a build failed due to
        deficiencies in the package (that aren't fixable without a new
        source version).
    -u, --uploaded: Record in the database that the packages build
        correctly and were uploaded.
    -n, --no-build: Record in the database that the packages aren't
        desired for this architecture and shouldn't appear in listings even
	if they're out of date.
    --dep-wait: Record in the database that the packages are waiting
        for some source dependencies to become available
    --binNMU num: Schedule a re-build of the package with unchanged source, but
         a new version number (source-version + "+b<num>")
    --give-back: Mark a package as ready to build that is in state Building,
	 Built or Build-Attempted. To give back a package in state Failed, use
	 --override. This command will actually put the package in state
	 BD-Uninstallable, until the installability of its Build-Dependencies
	 were verified. This happens at each call of --merge-all, usually
	 every 15 minutes.
    --merge-quinn: Merge quinn-diff output into database.
    --merge-packages: Merge Packages files into database.
    --pretend-avail: Pretend that given packages are available now and give
        free packages waiting for them
    -i SRC_PKG, --info SRC_PKG: Show information for source package
    -l STATE, --list=STATE: List all packages in state STATE; can be
        combined with -U to restrict to a specific user; STATE can
        also be 'all'
    -m MESSAGE, --message=MESSAGE: Give reason why package failed or
        source dependency list
        (used with -f, --dep-wait, and --binNMU)
    -o, --override: Override another user's lock on a package, i.e.
        take it over; a notice mail will be sent to the other user
    -U USER, --user=USER: select user name for which listings should
        apply, if not given all users are listed.
        if -l is missing, set user name to be entered in db; usually
        automatically choosen
    --import FILE: Import database from a ASCII file FILE
    --export FILE: Export database to a ASCII file FILE

The remaining arguments (depending on operation) usually start with
"name_version", the trailer is ignored. This allows to pass the names
of .dsc files, for which file name completion can be used.
--merge-packages and --merge-quinn take Package/quin--diff file names
on the command line or read stdin. --list needs nothing more on the
command line. --info takes source package names (without version).
EOF
	exit 1;
}

sub pkg_version_eq {
	my $pkg = shift;
	my $version = shift;

	return 1
	       if (defined $pkg->{'binary_nmu_version'}) and 
	       version_compare(binNMU_version($pkg->{'version'},
			$pkg->{'binary_nmu_version'}),'=', $version);
	return version_compare( $pkg->{'version'}, "=", $version );
}

sub table_name {
	return '"' . $arch . $schema_suffix . '".packages';
}

sub user_table_name {
	return '"' . $arch . $schema_suffix . '".users';
}

sub transactions_table_name {
	return '"' . $arch . $schema_suffix . '".transactions';
}

sub pkg_history_table_name {
	return '"' . $arch . $schema_suffix . '".pkg_history';
}

sub get_readonly_source_info {
	my $name = shift;
	# SELECT FLOOR(EXTRACT('epoch' FROM age(localtimestamp, '2010-01-22  23:45')) / 86400) -- change to that?
        my $q = "SELECT rel, priority, state_change, permbuildpri, section, buildpri, failed, state, binary_nmu_changelog, bd_problem, version, package, distribution, installed_version, notes, failed_category, builder, old_failed, previous_state, binary_nmu_version, depends, extract(days from date_trunc('days', now() - state_change)) as state_days"
            . ", (SELECT max(build_time) FROM ".pkg_history_table_name()." WHERE pkg_history.package = packages.package AND pkg_history.distribution = packages.distribution AND result = 'successful') AS successtime"
            . ", (SELECT max(build_time) FROM ".pkg_history_table_name()." WHERE pkg_history.package = packages.package AND pkg_history.distribution = packages.distribution ) AS anytime"
            . " FROM " .  table_name()
            . ' WHERE package = ? AND distribution = ?';
	my $pkg = $dbh->selectrow_hashref( $q,
		undef, $name, $distribution);
	return $pkg;
}

sub get_source_info {
	my $name = shift;
	my $pkg = $dbh->selectrow_hashref('SELECT *, extract(days from date_trunc(\'days\', now() - state_change)) as state_days FROM ' . 
		table_name() . ' WHERE package = ? AND distribution = ?' .
		' FOR UPDATE',
		undef, $name, $distribution);
	return $pkg;
}

sub get_all_source_info {
	my %options = @_;

        my $q = "SELECT rel, priority, state_change, permbuildpri, section, buildpri, failed, state, binary_nmu_changelog, bd_problem, version, package, distribution, installed_version, notes, failed_category, builder, old_failed, previous_state, binary_nmu_version, depends, extract(days from date_trunc('days', now() - state_change)) as state_days"
#            . ", (SELECT max(build_time) FROM ".pkg_history_table_name()." WHERE pkg_history.package = packages.package AND pkg_history.distribution = packages.distribution AND result = 'successful') AS successtime"
#            . ", (SELECT max(build_time) FROM ".pkg_history_table_name()." WHERE pkg_history.package = packages.package AND pkg_history.distribution = packages.distribution ) AS anytime"
            . ", successtime.build_time as successtime, anytime.build_time as anytime"
            . " FROM " .  table_name()
                . " left join ( "
                  . "select distinct on (package, distribution) build_time, package, distribution from ".pkg_history_table_name()." where result = 'successful' order by package, distribution, timestamp "
                  . " ) as successtime using (package, distribution) "
                . " left join ( "
                  . "select distinct on (package, distribution) build_time, package, distribution from ".pkg_history_table_name()." order by package, distribution, timestamp desc"
                  . " ) as anytime using (package, distribution) "
	    . " WHERE TRUE ";
        my @args = ();
        if ($distribution) {
            my @dists = split(/[, ]+/, $distribution);
            $q .= ' AND ( distribution = ? '.(' OR distribution = ? ' x $#dists).' )';
            foreach my $d ( @dists ) {
                push @args, ($d);
            }
        }
	if ($options{state} && uc($options{state}) ne "ALL") {
		$q .= ' AND upper(state) = ? ';
		push @args, uc($options{state});
	}

	if ($options{user} && uc($options{state}) ne "NEEDS-BUILD") { # if it's NEEDS-BUILD, we don't look at users
		#this basically means "this user, or no user at all":
		$q .= " AND (builder = ? OR upper(state) = 'NEEDS-BUILD')";
		push @args, $options{user};
	}

	if ($options{category}) {
		$q .= ' AND failed_category <> ? AND upper(state) = ? ';
		push @args, $options{category};
		push @args, "FAILED";
	}

	if ($options{list_min_age} > 0) {
		$q .= ' AND age(state_change) > ? ';
		push @args, $options{list_min_age} . " days";
	}

	if ($options{list_min_age} < 0) {
		$q .= ' AND age(state_change) < ? ';
		push @args, -$options{list_min_age} . " days";
	}

	my $db = $dbh->selectall_hashref($q, 'package', undef, @args);
	return $db;
}

sub update_source_info {
	my $pkg = shift;

	my $pkg2 = get_source_info($pkg->{'package'});
	if (! defined $pkg2)
	{
		add_source_info($pkg);
	}

	$dbh->do('UPDATE ' . table_name() . ' SET ' .
			'version = ?, ' .
			'state = ?, ' .
			'section = ?, ' .
			'priority = ?, ' .
			'installed_version = ?, ' .
			'previous_state = ?, ' .
			(($pkg->{'do_state_change'}) ? "state_change = now()," : "").
			'notes = ?, ' .
			'builder = ?, ' .
			'failed = ?, ' .
			'old_failed = ?, ' .
			'binary_nmu_version = ?, ' .
			'binary_nmu_changelog = ?, ' .
			'failed_category = ?, ' .
			'permbuildpri = ?, ' .
			'buildpri = ?, ' .
			'depends = ?, ' .
			'rel = ?, ' .
			'bd_problem = ? ' .
			'WHERE package = ? AND distribution = ?',
		undef,
		$pkg->{'version'},
		$pkg->{'state'},
		$pkg->{'section'},
		$pkg->{'priority'},
		$pkg->{'installed_version'},
		$pkg->{'previous_state'},
		$pkg->{'notes'},
		$pkg->{'builder'},
		$pkg->{'failed'},
		$pkg->{'old_failed'},
		$pkg->{'binary_nmu_version'},
		$pkg->{'binary_nmu_changelog'},
		$pkg->{'failed_category'},
		$pkg->{'permbuildpri'},
		$pkg->{'buildpri'},
		$pkg->{'depends'},
		$pkg->{'rel'},
		$pkg->{'bd_problem'},
		$pkg->{'package'},
		$distribution) or die $dbh->errstr;
}

sub add_source_info {
	my $pkg = shift;
	$dbh->do('INSERT INTO ' . table_name() .
			' (package, distribution) values (?, ?)',
		undef, $pkg->{'package'}, $distribution) or die $dbh->errstr;
}

sub del_source_info {
	my $name = shift;
	$dbh->do('DELETE FROM ' . table_name() .
			' WHERE package = ? AND distribution = ?',
		undef, $name, $distribution) or die $dbh->errstr;
}

sub get_user_info {
	my $name = shift;
	my $user = $dbh->selectrow_hashref('SELECT * FROM ' . 
		user_table_name() . ' WHERE username = ? AND distribution = ?',
		undef, $name, $distribution);
	return $user;
}

sub update_user_info {
	my $user = shift;
	$dbh->do('UPDATE ' . user_table_name() .
			' SET last_seen = now() WHERE username = ?' .
			' AND distribution = ?',
		undef, $user, $distribution)
		or die $dbh->errstr;
}


sub add_user_info {
	my $user = shift;
	$dbh->do('INSERT INTO ' . user_table_name() .
			' (username, distribution, last_seen)' .
			' values (?, ?, now())',
		undef, $user, $distribution)
		or die $dbh->errstr;
}

sub lock_table()
{
	$dbh->do('LOCK TABLE ' . table_name() .
		' IN EXCLUSIVE MODE', undef) or die $dbh->errstr;
}

